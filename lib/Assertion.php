<?php
namespace PHPUnit\Expect;

use PHPUnit\Framework\{Assert};
use PHPUnit\Framework\Constraint\{Constraint};

/**
 * Represents a test assertion.
 *
 * @property Assertion $a Chainable getter to improve the assertion readability.
 * @property Assertion $an Chainable getter to improve the assertion readability.
 * @property Assertion $and Chainable getter to improve the assertion readability.
 * @property Assertion $at Chainable getter to improve the assertion readability.
 * @property Assertion $be Chainable getter to improve the assertion readability.
 * @property Assertion $been Chainable getter to improve the assertion readability.
 * @property Assertion $but Chainable getter to improve the assertion readability.
 * @property Assertion $directory Indicates that the assertion following in the chain targets a directory.
 * @property Assertion $does Chainable getter to improve the assertion readability.
 * @property Assertion $empty Reports an error if the target is not empty.
 * @property Assertion $exist Reports an error if the file or directory specified by the target does not exist.
 * @property Assertion $false Reports an error if the target is `true`.
 * @property Assertion $file Indicates that the assertion following in the chain targets a file.
 * @property Assertion $has Chainable getter to improve the assertion readability.
 * @property Assertion $have Chainable getter to improve the assertion readability.
 * @property Assertion $infinite Reports an error if the target is not `INF`.
 * @property Assertion $is Chainable getter to improve the assertion readability.
 * @property Assertion $json Indicates that the assertion following in the chain targets JSON data.
 * @property Assertion $length Indicates that the assertion following in the chain targets a length.
 * @property Assertion $NaN Reports an error if the target is not `NAN`.
 * @property Assertion $not Negates any of assertions following in the chain.
 * @property Assertion $null Reports an error if the target is not `null`.
 * @property Assertion $of Chainable getter to improve the assertion readability.
 * @property Assertion $readable Reports an error if the file or directory specified by the target is not readable.
 * @property Assertion $same Chainable getter to improve the assertion readability.
 * @property Assertion $that Chainable getter to improve the assertion readability.
 * @property Assertion $throw Reports an error if the function target does not throw an exception.
 * @property Assertion $to Chainable getter to improve the assertion readability.
 * @property Assertion $true Reports an error if the target is `false`.
 * @property Assertion $which Chainable getter to improve the assertion readability.
 * @property Assertion $with Chainable getter to improve the assertion readability.
 * @property Assertion $writable Reports an error if the file or directory specified by the target is not writable.
 * @property Assertion $xml Indicates that the assertion following in the chain targets XML data.
 */
class Assertion {

  /**
   * @var array The assertion flags
   */
  private $flags = [];

  /**
   * @var string Message identifying the error generated by the assertion when it fails.
   */
  private $message;

  /**
   * @var mixed The target of the assertion.
   */
  private $target;

  /**
   * Assertion constructor.
   * @param mixed $target The target of the assertion.
   * @param string $message Message identifying the error generated by the assertion when it fails.
   */
  public function __construct($target, string $message = '') {
    $this->target = $target;
    $this->message = $message;
  }

  /**
   * Invokes the instance method with the specified name.
   * @param string $name The name of the method to invoke.
   * @return mixed The return value of the invoked method.
   * @throws \InvalidArgumentException The specified method is not found.
   */
  public function __get(string $name) {
    static $reflection;
    if (!$reflection) $reflection = new \ReflectionClass(static::class);

    if ($reflection->hasMethod($name)) {
      $method = $reflection->getMethod($name);
      if ($method->isPublic() && !$method->getNumberOfRequiredParameters()) return $this->$name();
    }

    throw new \InvalidArgumentException("The specified method is not found: $name");
  }

  /**
   * Reports an error if the target is not of the specified type.
   * This method can also be used as language chain.
   * @param string $type The type to check. Specify an empty string to use as language chain.
   * @return Assertion This instance.
   */
  public function a(string $type = ''): self {
    return mb_strlen($type) ? $this->expect($this->target, Assert::isType($type)) : $this;
  }

  /**
   * Reports an error if the target is not greater than the specified value.
   * @param int|float $value The value to compare.
   * @return Assertion This instance.
   */
  public function above($value): self {
    $target = $this->hasFlag('length') ? $this->getLength($this->target) : $this->target;
    return $this->expect($target, Assert::greaterThan($value));
  }

  /**
   * Reports an error if the target is not of the specified type.
   * This method can also be used as language chain.
   * @param string $type The type to check. Specify an empty string to use as language chain.
   * @return Assertion This instance.
   * @see Assertion::a()
   */
  public function an(string $type = ''): self {
    return $this->a($type);
  }

  /**
   * Chainable getter to improve the assertion readability.
   * @return Assertion This instance.
   */
  public function and(): self {
    return $this;
  }

  /**
   * Chainable getter to improve the assertion readability.
   * @return Assertion This instance.
   */
  public function at(): self {
    return $this;
  }

  /**
   * Chainable getter to improve the assertion readability.
   * @return Assertion This instance.
   */
  public function be(): self {
    return $this;
  }

  /**
   * Chainable getter to improve the assertion readability.
   * @return Assertion This instance.
   */
  public function been(): self {
    return $this;
  }

  /**
   * Reports an error if the target is not less than the specified value.
   * @param int|float $value The value to compare.
   * @return Assertion This instance.
   */
  public function below($value): self {
    $target = $this->hasFlag('length') ? $this->getLength($this->target) : $this->target;
    return $this->expect($target, Assert::lessThan($value));
  }

  /**
   * Chainable getter to improve the assertion readability.
   * @return Assertion This instance.
   */
  public function but(): self {
    return $this;
  }

  /**
   * Reports an error if the target is not equal to the specified value, within a given delta range.
   * @param int|float $value The value to compare.
   * @param float $delta The allowed distance between two values to consider them equal.
   * @return Assertion This instance.
   */
  public function closeTo($value, float $delta): self {
    return $this->expect($this->target, Assert::equalTo($value, $delta));
  }

  /**
   * Reports an error if the target does not contain an element or a substring.
   * @param mixed $value The value to find.
   * @return Assertion This instance.
   */
  public function contain($value = null): self {
    return $this->contain($value);
  }

  /**
   * Reports an error if the target does not contain an element or a substring.
   * @param mixed $value The value to find.
   * @return Assertion This instance.
   * @see Assertion::contain()
   */
  public function contains($value = null): self {
    if (!func_num_args()) {
      $this->setFlag('contain');
      return $this;
    }

    return $this->expect($this->target, is_string($this->target) ? Assert::stringContains($value) : Assert::contains($value));
  }

  /**
   * Reports an error if the target does not contain only variables of a given type.
   * @param string $type The type to check.
   * @return Assertion This instance.
   */
  public function containOnly(string $type): self {
    return $this->expect($this->target, Assert::containsOnly($type));
  }

  /**
   * Reports an error if the target does not contain only instances of a given class.
   * @param string $className The name of the class to check.
   * @return Assertion This instance.
   */
  public function containOnlyInstancesOf(string $className): self {
    return $this->expect($this->target, Assert::containsOnlyInstancesOf($className));
  }

  /**
   * Indicates that the assertion following in the chain targets a directory.
   * @return Assertion This instance.
   */
  public function directory(): self {
    $this->setFlag('directory');
    return $this;
  }

  /**
   * Chainable getter to improve the assertion readability.
   * @return Assertion This instance.
   */
  public function does(): self {
    return $this;
  }

  /**
   * Reports an error if the target is not empty.
   * For arrays, strings, and `Countable` instances, it checks the length. For objects, it gets the count of accessible properties according to scope.
   * @return Assertion This instance.
   */
  public function empty(): self {
    if (is_object($this->target) && !($this->target instanceof \Countable)) {
      $constraint = Assert::countOf(0);
      $target = get_object_vars($this->target);
    }
    else if (is_string($this->target)) {
      $constraint = Assert::equalTo(0);
      $target = mb_strlen($this->target);

      // TODO file/directory flag handling!
    }
    else {
      $constraint = Assert::isEmpty();
      $target = $this->target;
    }

    return $this->expect($target, $constraint);
  }

  /**
   * Reports an error if the target does not end with the specified suffix.
   * @param string $value The suffix to check.
   * @return Assertion This instance.
   */
  public function endWith(string $value): self {
    return $this->expect($this->target, Assert::stringEndsWith($value));
  }

  /**
   * Reports an error if the target and the specified value are not equal.
   * @param mixed $value The value to compare.
   * @return Assertion This instance.
   */
  public function equal($value): self {
    if ($this->hasFlag('file')) {
      if ($this->hasFlag('negate')) Assert::assertFileNotEquals($value, $this->target, $this->message);
      else Assert::assertFileEquals($value, $this->target, $this->message);
      return $this;
    }

    $target = $this->hasFlag('length') ? $this->getLength($this->target) : $this->target;
    return $this->expect($target, Assert::equalTo($value));
  }

  /**
   * Reports an error if the target and the specified value are not equal.
   * @param mixed $value The value to compare.
   * @return Assertion This instance.
   * @see Assertion::equal()
   */
  public function equals($value): self {
    return $this->equal($value);
  }

  /**
   * Reports an error if the file or directory specified by the target does not exist.
   * @return Assertion This instance.
   * @throws \BadMethodCallException This assertion is not a file or directory one.
   */
  public function exist(): self {
    if ($this->hasFlag('directory')) $constraint = Assert::directoryExists();
    else if ($this->hasFlag('file')) $constraint = Assert::fileExists();
    else throw new \BadMethodCallException('This assertion is not a file or directory one.');

    return $this->expect($this->target, $constraint);
  }

  /**
   * Reports an error if the target is `true`.
   * @return Assertion This instance.
   */
  public function false(): self {
    return $this->expect($this->target, Assert::isFalse());
  }

  /**
   * Indicates that the assertion following in the chain targets a file.
   * @return Assertion This instance.
   */
  public function file(): self {
    $this->setFlag('file');
    return $this;
  }

  /**
   * Chainable getter to improve the assertion readability.
   * @return Assertion This instance.
   */
  public function has(): self {
    return $this;
  }

  /**
   * Chainable getter to improve the assertion readability.
   * @return Assertion This instance.
   */
  public function have(): self {
    return $this;
  }

  /**
   * Reports an error if the target and the specified variable do not have the same type and value.
   * @param mixed $value The variable to compare.
   * @return Assertion This instance.
   */
  public function identicalTo($value): self {
    return $this->expect($this->target, Assert::identicalTo($value));
  }

  /**
   * Reports an error if the target does not contain an element or a substring.
   * @param mixed $value The value to find.
   * @return Assertion This instance.
   * @see Assertion::contain()
   */
  public function include($value = null): self {
    return $this->contain($value);
  }

  /**
   * Reports an error if the target does not contain an element or a substring.
   * @param mixed $value The value to find.
   * @return Assertion This instance.
   * @see Assertion::contain()
   */
  public function includes($value = null): self {
    return $this->contain($value);
  }

  /**
   * Reports an error if the target is not `INF`.
   * @return Assertion This instance.
   */
  public function infinite(): self {
    return $this->expect($this->target, Assert::isInfinite());
  }

  /**
   * Reports an error if the target is not an instance of the specified class.
   * @param string $className The name of the class to test.
   * @return Assertion This instance.
   */
  public function instanceOf(string $className): self {
    return $this->expect($this->target, Assert::isInstanceOf($className));
  }

  /**
   * Chainable getter to improve the assertion readability.
   * @return Assertion This instance.
   */
  public function is(): self {
    return $this;
  }

  /**
   * Indicates that the assertion following in the chain targets JSON data.
   * @return Assertion This instance.
   */
  public function json(): self {
    $this->setFlag('json');
    return $this;
  }

  /**
   * Reports an error if the target is not greater than or equal to the specified value.
   * @param int|float $value The value to compare.
   * @return Assertion This instance.
   */
  public function least($value): self {
    $target = $this->hasFlag('length') ? $this->getLength($this->target) : $this->target;
    return $this->expect($target, Assert::greaterThanOrEqual($value));
  }

  /**
   * Reports an error if the length of the target is not the expected one.
   * @param int $value The expected length.
   * @return Assertion This instance.
   * @see Assertion::lengthOf()
   */
  public function length(int $value = null): self {
    return $this->lengthOf($value);
  }

  /**
   * Reports an error if the length of the target is not the expected one.
   * @param int $value The expected length.
   * @return Assertion This instance.
   */
  public function lengthOf(int $value = null): self {
    if (!func_num_args()) {
      $this->setFlag('length');
      return $this;
    }

    if (is_string($this->target)) {
      $constraint = Assert::equalTo($value);
      $target = mb_strlen($this->target);
    }
    else {
      $constraint = Assert::countOf($value);
      $target = $this->target;
    }

    return $this->expect($target, $constraint);
  }

  /**
   * Reports an error if the target does not match the specified regular expression.
   * @param string $pattern The regular expression to test.
   * @return Assertion This instance.
   */
  public function match(string $pattern): self {
    return $this->expect($this->target, Assert::matchesRegularExpression($pattern));
  }

  /**
   * Reports an error if the target does not match the specified format string.
   * @param string $format The format string to test.
   * @return Assertion This instance.
   */
  public function matchFormat(string $format): self {
    return $this->expect($this->target, Assert::matches($format));
  }

  /**
   * Reports an error if the target is not less than or equal to the specified value.
   * @param int|float $value The value to compare.
   * @return Assertion This instance.
   */
  public function most($value): self {
    $target = $this->hasFlag('length') ? $this->getLength($this->target) : $this->target;
    return $this->expect($target, Assert::lessThanOrEqual($value));
  }

  /**
   * Reports an error if the target is not `NAN`.
   * @return Assertion This instance.
   */
  public function NaN(): self {
    return $this->expect($this->target, Assert::isNan());
  }

  /**
   * Negates any of assertions following in the chain.
   * @return Assertion This instance.
   */
  public function not(): self {
    $this->setFlag('negate');
    return $this;
  }

  /**
   * Reports an error if the target is not `null`.
   * @return Assertion This instance.
   */
  public function null(): self {
    return $this->expect($this->target, Assert::isNull());
  }

  /**
   * Chainable getter to improve the assertion readability.
   * @return Assertion This instance.
   */
  public function of(): self {
    return $this;
  }

  /**
   * Reports an error if the target is not contained in the specified list or string.
   * @param array|\Traversable $value The value provider.
   * @return Assertion This instance.
   */
  public function oneOf($value): self {
    return $this->expect($value, Assert::contains($this->target));
  }

  /**
   * Indicates that the assertion following in the chain targets a file.
   * @return Assertion This instance.
   */
  public function ordered(): self {
    $this->setFlag('ordered');
    return $this;
  }

  /**
   * Reports an error if the target has not a given property or key.
   *
   * Optionally asserts that the value of that property or key is equal to the specified value.
   * Changes the subject of the assertion to be the value of that property from the original object.
   *
   * @param string $name The property name.
   * @param mixed $value The property value.
   * @return Assertion This instance.
   * @throws \BadMethodCallException The target is not an array nor an object.
   */
  public function property(string $name, $value = null) {
    $isArray = is_array($this->target) || $this->target instanceof \ArrayAccess;
    if (!$isArray && !is_object($this->target)) throw new \BadMethodCallException('The target is not an array nor an object.');

    $hasProperty = $isArray ? array_key_exists($name, $this->target) : property_exists($this->target, $name);
    $hasPropertyConstraint = $isArray ? Assert::arrayHasKey($name) : Assert::objectHasAttribute($name);
    $property = $isArray ? ($this->target[$name] ?? null) : ($this->target->$name ?? null);

    $argsCount = func_num_args();
    if ($argsCount == 1 || !$hasProperty) $this->expect($this->target, $hasPropertyConstraint);
    else {
      Assert::assertThat($this->target, $hasPropertyConstraint);
      $this->expect($property, Assert::equalTo($value));
    }

    $this->target = $property;
    return $this;
  }

  /**
   * Reports an error if the file or directory specified by the target is not readable.
   * @return Assertion This instance.
   * @throws \BadMethodCallException This assertion is not a file or directory one.
   */
  public function readable(): self {
    if (!$this->hasFlag('directory') && !$this->hasFlag('file'))
      throw new \BadMethodCallException('This assertion is not a file or directory one.');

    $constraint = Assert::logicalAnd($this->hasFlag('file') ? Assert::fileExists() : Assert::directoryExists(), Assert::isReadable());
    return $this->expect($this->target, $constraint);
  }

  /**
   * Chainable getter to improve the assertion readability.
   * @return Assertion This instance.
   */
  public function same(): self {
    return $this;
  }

  /**
   * Reports an error if the target does not pass a given truth test.
   * @param callable $predicate The predicate to invoke.
   * @return Assertion This instance.
   */
  public function satisfy(callable $predicate): self {
    return $this->expect(call_user_func($predicate, $this->target), Assert::isTrue());
  }

  /**
   * Reports an error if the target does not start with the specified prefix.
   * @param string $value The prefix to check.
   * @return Assertion This instance.
   */
  public function startWith(string $value): self {
    return $this->expect($this->target, Assert::stringStartsWith($value));
  }

  /**
   * Chainable getter to improve the assertion readability.
   * @return Assertion This instance.
   */
  public function that(): self {
    return $this;
  }

  /**
   * Chainable getter to improve the assertion readability.
   * @return Assertion This instance.
   */
  public function to(): self {
    return $this;
  }

  /**
   * Reports an error if the function target does not throw a given exception.
   * @param string $className The class name of the exception.
   * @return Assertion This instance.
   * @throws \BadMethodCallException The function target is not callable.
   */
  public function throw(string $className = ''): self {
    if (!is_callable($this->target)) throw new \BadMethodCallException('The function target is not callable.');

    $exception = null;
    try { call_user_func($this->target); }
    catch (\Throwable $e) { $exception = $e; }

    $constraint = Assert::logicalNot(Assert::isNull());
    return $this->expect($exception, mb_strlen($className) ? Assert::logicalAnd($constraint, Assert::isInstanceOf($className)) : $constraint);
  }

  /**
   * Reports an error if the target is `false`.
   * @return Assertion This instance.
   */
  public function true(): self {
    return $this->expect($this->target, Assert::isTrue());
  }

  /**
   * Chainable getter to improve the assertion readability.
   * @return Assertion This instance.
   */
  public function which(): self {
    return $this;
  }

  /**
   * Chainable getter to improve the assertion readability.
   * @return Assertion This instance.
   */
  public function with(): self {
    return $this;
  }

  /**
   * Reports an error if the target is greater than or less than the specified bounds.
   * @param int|float $start The lowerbound inclusive.
   * @param int|float $finish The upperbound inclusive.
   * @return Assertion This instance.
   */
  public function within($start, $finish): self {
    $target = $this->hasFlag('length') ? $this->getLength($this->target) : $this->target;
    return $this->expect($target, Assert::logicalAnd(Assert::greaterThanOrEqual($start), Assert::lessThanOrEqual($finish)));
  }

  /**
   * Reports an error if the file or directory specified by the target is not writable.
   * @return Assertion This instance.
   * @throws \BadMethodCallException This assertion is not a file or directory one.
   */
  public function writable(): self {
    if (!$this->hasFlag('directory') && !$this->hasFlag('file'))
      throw new \BadMethodCallException('This assertion is not a file or directory one.');

    $constraint = Assert::logicalAnd($this->hasFlag('file') ? Assert::fileExists() : Assert::directoryExists(), Assert::isWritable());
    return $this->expect($this->target, $constraint);
  }

  /**
   * Indicates that the assertion following in the chain targets XML data.
   * @return Assertion This instance.
   */
  public function xml(): self {
    $this->setFlag('xml');
    return $this;
  }

  /**
   * Asserts that the specified target matches the specified constraint.
   * @param mixed $target The target to check.
   * @param Constraint $constraint The constraint to match.
   * @return Assertion This instance.
   */
  private function expect($target, Constraint $constraint) {
    Assert::assertThat($target, $this->hasFlag('negate') ? Assert::logicalNot($constraint) : $constraint, $this->message);
    return $this;
  }

  /**
   * Returns the length of the specified value.
   * @param mixed $value An iterable value, like an array or a string.
   * @return int The length of the specified value.
   * @throws \InvalidArgumentException The specified value is not iterable.
   */
  private function getLength($value): int {
    if (is_array($value) || $value instanceof \Countable) return count($value);
    if ($value instanceof \Traversable) return iterator_count($value);
    if (is_string($value)) return mb_strlen($value);
    throw new \InvalidArgumentException("The specified value is not iterable: $value");
  }

  /**
   * Gets a value indicating whether this assertion has the specified flag.
   * @param string $name The flag name.
   * @return bool `true` if this assertion has the specified flag, otherwise `false`.
   */
  private function hasFlag(string $name): bool {
    return $this->flags[$name] ?? false;
  }

  /**
   * Sets a value indicating whether this assertion has the specified flag.
   * @param string $name The flag name.
   * @param bool $value `true` if this assertion has the specified flag, otherwise `false`.
   */
  private function setFlag(string $name, bool $value = true) {
    $this->flags[$name] = $value;
  }
}
