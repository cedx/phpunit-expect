<?php declare(strict_types=1);
namespace PHPUnit\Expect;

use PHPUnit\Framework\Constraint\{Constraint};

/**
 * Represents a test assertion.
 *
 * @property Assertion $a Chainable getter to improve the assertion readability.
 * @property Assertion $an Chainable getter to improve the assertion readability.
 * @property Assertion $and Chainable getter to improve the assertion readability.
 * @property Assertion $at Chainable getter to improve the assertion readability.
 * @property Assertion $be Chainable getter to improve the assertion readability.
 * @property Assertion $been Chainable getter to improve the assertion readability.
 * @property Assertion $but Chainable getter to improve the assertion readability.
 * @property Assertion $directory Indicates that the assertion following in the chain targets a directory.
 * @property Assertion $does Chainable getter to improve the assertion readability.
 * @property Assertion $empty Reports an error if the target is not empty.
 * @property Assertion $exist Reports an error if the file or directory specified by the target does not exist.
 * @property Assertion $false Reports an error if the target is `true`.
 * @property Assertion $file Indicates that the assertion following in the chain targets a file.
 * @property Assertion $has Chainable getter to improve the assertion readability.
 * @property Assertion $have Chainable getter to improve the assertion readability.
 * @property Assertion $infinite Reports an error if the target is not `INF`.
 * @property Assertion $is Chainable getter to improve the assertion readability.
 * @property Assertion $json Indicates that the assertion following in the chain targets JSON data.
 * @property Assertion $length Indicates that the assertion following in the chain targets a length.
 * @property Assertion $lengthOf Indicates that the assertion following in the chain targets a length.
 * @property Assertion $NaN Reports an error if the target is not `NAN`.
 * @property Assertion $not Negates any of assertions following in the chain.
 * @property Assertion $null Reports an error if the target is not `null`.
 * @property Assertion $of Chainable getter to improve the assertion readability.
 * @property Assertion $readable Reports an error if the file or directory specified by the target is not readable.
 * @property Assertion $same Chainable getter to improve the assertion readability.
 * @property Assertion $still Chainable getter to improve the assertion readability.
 * @property Assertion $that Chainable getter to improve the assertion readability.
 * @property Assertion $throw Reports an error if the function target does not throw an exception.
 * @property Assertion $to Chainable getter to improve the assertion readability.
 * @property Assertion $true Reports an error if the target is `false`.
 * @property Assertion $which Chainable getter to improve the assertion readability.
 * @property Assertion $with Chainable getter to improve the assertion readability.
 * @property Assertion $writable Reports an error if the file or directory specified by the target is not writable.
 * @property Assertion $xml Indicates that the assertion following in the chain targets XML data.
 */
class Assertion {
  use ChainTrait;

  /** @var array The assertion flags. */
  private $flags = [];

  /** @var string Message identifying the error generated by the assertion when it fails. */
  private $message;

  /** @var mixed The target of the assertion. */
  private $target;

  /**
   * Assertion constructor.
   * @param mixed $target The target of the assertion.
   * @param string $message Message identifying the error generated by the assertion when it fails.
   */
  function __construct($target, string $message = '') {
    $this->target = $target;
    $this->message = $message;
  }

  /**
   * Invokes the instance method with the specified name.
   * @param string $name The name of the method to invoke.
   * @return mixed The return value of the invoked method.
   * @throws \InvalidArgumentException The specified method is not found.
   */
  function __get(string $name) {
    static $reflection;
    if (!$reflection) $reflection = new \ReflectionClass(static::class);

    if ($reflection->hasMethod($name)) {
      $method = $reflection->getMethod($name);
      if ($method->isPublic() && !$method->getNumberOfRequiredParameters()) return $this->$name();
    }

    throw new \InvalidArgumentException("The specified method is not found: $name()");
  }

  /**
   * Reports an error if the target is not of the specified type.
   * This method can also be used as language chain.
   * @param string $type The type to check. Specify an empty string to use as language chain.
   * @return $this This instance.
   */
  function a(string $type = ''): self {
    return mb_strlen($type) ? $this->expect($this->target, isType($type)) : $this;
  }

  /**
   * Reports an error if the target is not greater than the specified value.
   * @param int|float $value The value to compare.
   * @return $this This instance.
   */
  function above($value): self {
    $target = $this->hasFlag('length') ? $this->getLength($this->target) : $this->target;
    return $this->expect($target, greaterThan($value));
  }

  /**
   * Reports an error if the target is not of the specified type.
   * This method can also be used as language chain.
   * @param string $type The type to check. Specify an empty string to use as language chain.
   * @return $this This instance.
   * @see Assertion::a()
   */
  function an(string $type = ''): self {
    return $this->a($type);
  }

  /**
   * Reports an error if the target is not less than the specified value.
   * @param int|float $value The value to compare.
   * @return $this This instance.
   */
  function below($value): self {
    $target = $this->hasFlag('length') ? $this->getLength($this->target) : $this->target;
    return $this->expect($target, lessThan($value));
  }

  /**
   * Reports an error if the target is not equal to the specified value, within a given delta range.
   * @param int|float $value The value to compare.
   * @param float $delta The allowed distance between two values to consider them equal.
   * @return $this This instance.
   */
  function closeTo($value, float $delta): self {
    return $this->expect($this->target, equalTo($value, $delta));
  }

  /**
   * Reports an error if the target does not contain an element or a substring.
   * @param mixed $value The value to find.
   * @return $this This instance.
   */
  function contain($value = null): self {
    if ($this->hasFlag('file')) return $this->expect(@file_get_contents($this->target), stringContains($value));
    return $this->expect($this->target, is_string($this->target) ? stringContains($value) : contains($value));
  }

  /**
   * Reports an error if the target does not contain an element or a substring.
   * @param mixed $value The value to find.
   * @return $this This instance.
   * @see Assertion::contain()
   */
  function contains($value = null): self {
    return $this->contain($value);
  }

  /**
   * Reports an error if the target does not contain only variables of a given type.
   * @param string $type The type to check.
   * @return $this This instance.
   */
  function containOnly(string $type): self {
    return $this->expect($this->target, containsOnly($type));
  }

  /**
   * Reports an error if the target does not contain only instances of a given class.
   * @param string $className The name of the class to check.
   * @return $this This instance.
   */
  function containOnlyInstancesOf(string $className): self {
    return $this->expect($this->target, containsOnlyInstancesOf($className));
  }

  /**
   * Indicates that the assertion following in the chain targets a directory.
   * @return $this This instance.
   */
  function directory(): self {
    return $this->setFlag('directory');
  }

  /**
   * Reports an error if the target is not empty.
   * For arrays, strings, and `Countable` instances, it checks the length. For objects, it gets the count of accessible properties according to scope.
   * @return $this This instance.
   */
  function empty(): self {
    if (is_object($this->target) && !($this->target instanceof \Countable)) {
      $constraint = countOf(0);
      $target = get_object_vars($this->target);
    }
    else if (is_string($this->target)) {
      $constraint = equalTo(0);
      $target = $this->hasFlag('file') ? @filesize($this->target) : mb_strlen($this->target);
      // TODO file/directory flag handling!
    }
    else {
      $constraint = isEmpty();
      $target = $this->target;
    }

    return $this->expect($target, $constraint);
  }

  /**
   * Reports an error if the target does not end with the specified suffix.
   * @param string $value The suffix to check.
   * @return $this This instance.
   */
  function endWith(string $value): self {
    return $this->expect($this->target, stringEndsWith($value));
  }

  /**
   * Reports an error if the target and the specified value are not equal.
   * @param mixed $value The value to compare.
   * @return $this This instance.
   */
  function equal($value): self {
    if ($this->hasFlag('file')) {
      if ($this->hasFlag('negate')) assertFileNotEquals($value, $this->target, $this->message);
      else assertFileEquals($value, $this->target, $this->message);
      return $this;
    }

    $target = $this->hasFlag('length') ? $this->getLength($this->target) : $this->target;
    return $this->expect($target, equalTo($value));
  }

  /**
   * Reports an error if the target and the specified value are not equal.
   * @param mixed $value The value to compare.
   * @return $this This instance.
   * @see Assertion::equal()
   */
  function equals($value): self {
    return $this->equal($value);
  }

  /**
   * Reports an error if the file or directory specified by the target does not exist.
   * @return $this This instance.
   * @throws \BadMethodCallException This assertion is not a file or directory one.
   */
  function exist(): self {
    if ($this->hasFlag('directory')) $constraint = directoryExists();
    else if ($this->hasFlag('file')) $constraint = fileExists();
    else throw new \BadMethodCallException('This assertion is not a file or directory one.');

    return $this->expect($this->target, $constraint);
  }

  /**
   * Reports an error if the target is `true`.
   * @return $this This instance.
   */
  function false(): self {
    return $this->expect($this->target, isFalse());
  }

  /**
   * Indicates that the assertion following in the chain targets a file.
   * @return $this This instance.
   */
  function file(): self {
    return $this->setFlag('file');
  }

  /**
   * Reports an error if the target and the specified variable do not have the same type and value.
   * @param mixed $value The variable to compare.
   * @return $this This instance.
   */
  function identicalTo($value): self {
    return $this->expect($this->target, identicalTo($value));
  }

  /**
   * Reports an error if the target does not contain an element or a substring.
   * @param mixed $value The value to find.
   * @return $this This instance.
   * @see Assertion::contain()
   */
  function include($value = null): self {
    return $this->contain($value);
  }

  /**
   * Reports an error if the target does not contain an element or a substring.
   * @param mixed $value The value to find.
   * @return $this This instance.
   * @see Assertion::contain()
   */
  function includes($value = null): self {
    return $this->contain($value);
  }

  /**
   * Reports an error if the target is not `INF`.
   * @return $this This instance.
   */
  function infinite(): self {
    return $this->expect($this->target, isInfinite());
  }

  /**
   * Reports an error if the target is not an instance of the specified class.
   * @param string $className The name of the class to test.
   * @return $this This instance.
   */
  function instanceOf(string $className): self {
    return $this->expect($this->target, isInstanceOf($className));
  }

  /**
   * Indicates that the assertion following in the chain targets JSON data.
   * @return $this This instance.
   */
  function json(): self {
    return $this->setFlag('json');
  }

  /**
   * Reports an error if the target is not greater than or equal to the specified value.
   * @param int|float $value The value to compare.
   * @return $this This instance.
   */
  function least($value): self {
    $target = $this->hasFlag('length') ? $this->getLength($this->target) : $this->target;
    return $this->expect($target, greaterThanOrEqual($value));
  }

  /**
   * Reports an error if the length of the target is not the expected one.
   * @param int $value The expected length.
   * @return $this This instance.
   * @see Assertion::lengthOf()
   */
  function length(int $value = null): self {
    return $this->lengthOf($value);
  }

  /**
   * Reports an error if the length of the target is not the expected one.
   * @param int $value The expected length.
   * @return $this This instance.
   */
  function lengthOf(int $value = null): self {
    if ($value === null) return $this->setFlag('length');

    if (is_string($this->target)) {
      $constraint = equalTo($value);
      $target = mb_strlen($this->target);
    }
    else {
      $constraint = countOf($value);
      $target = $this->target;
    }

    return $this->expect($target, $constraint);
  }

  /**
   * Reports an error if the target does not match the specified regular expression.
   * @param string $pattern The regular expression to test.
   * @return $this This instance.
   */
  function match(string $pattern): self {
    return $this->expect($this->target, matchesRegularExpression($pattern));
  }

  /**
   * Reports an error if the target does not match the specified format string.
   * @param string $format The format string to test.
   * @return $this This instance.
   */
  function matchFormat(string $format): self {
    return $this->expect($this->target, matches($format));
  }

  /**
   * Reports an error if the target is not less than or equal to the specified value.
   * @param int|float $value The value to compare.
   * @return $this This instance.
   */
  function most($value): self {
    $target = $this->hasFlag('length') ? $this->getLength($this->target) : $this->target;
    return $this->expect($target, lessThanOrEqual($value));
  }

  /**
   * Reports an error if the target is not `NAN`.
   * @return $this This instance.
   */
  function NaN(): self {
    return $this->expect($this->target, isNan());
  }

  /**
   * Negates any of assertions following in the chain.
   * @return $this This instance.
   */
  function not(): self {
    return $this->setFlag('negate');
  }

  /**
   * Reports an error if the target is not `null`.
   * @return $this This instance.
   */
  function null(): self {
    return $this->expect($this->target, isNull());
  }

  /**
   * Reports an error if the target is not contained in the specified list or string.
   * @param array|\Traversable $value The value provider.
   * @return $this This instance.
   */
  function oneOf($value): self {
    return $this->expect($value, contains($this->target));
  }

  /**
   * Indicates that the assertion following in the chain targets a file.
   * @return $this This instance.
   */
  function ordered(): self {
    return $this->setFlag('ordered');
  }

  /**
   * Reports an error if the target has not a given property or key.
   *
   * Optionally asserts that the value of that property or key is equal to the specified value.
   * Changes the subject of the assertion to be the value of that property from the original object.
   *
   * @param string $name The property name.
   * @param mixed $value The property value.
   * @return $this This instance.
   * @throws \BadMethodCallException The target is not an array nor an object.
   */
  function property(string $name, $value = null): self {
    $isArray = is_array($this->target) || $this->target instanceof \ArrayAccess;
    if (!$isArray && !is_object($this->target)) throw new \BadMethodCallException('The target is not an array nor an object.');

    $hasProperty = $isArray ? array_key_exists($name, $this->target) : property_exists($this->target, $name);
    $hasPropertyConstraint = $isArray ? arrayHasKey($name) : objectHasAttribute($name);
    $property = $isArray ? ($this->target[$name] ?? null) : ($this->target->$name ?? null);

    if (!$hasProperty || $value === null) $this->expect($this->target, $hasPropertyConstraint);
    else {
      assertThat($this->target, $hasPropertyConstraint);
      $this->expect($property, equalTo($value));
    }

    $this->target = $property;
    return $this;
  }

  /**
   * Reports an error if the file or directory specified by the target is not readable.
   * @return $this This instance.
   * @throws \BadMethodCallException This assertion is not a file or directory one.
   */
  function readable(): self {
    if (!$this->hasFlag('directory') && !$this->hasFlag('file'))
      throw new \BadMethodCallException('This assertion is not a file or directory one.');

    return $this->expect($this->target, isReadable());
  }

  /**
   * Reports an error if the target does not pass a given truth test.
   * @param callable $predicate The predicate to invoke.
   * @return $this This instance.
   */
  function satisfy(callable $predicate): self {
    return $this->expect(call_user_func($predicate, $this->target), isTrue());
  }

  /**
   * Reports an error if the target does not start with the specified prefix.
   * @param string $value The prefix to check.
   * @return $this This instance.
   */
  function startWith(string $value): self {
    return $this->expect($this->target, stringStartsWith($value));
  }

  /**
   * Reports an error if the function target does not throw a given exception.
   * @param string $className The class name of the exception.
   * @return $this This instance.
   * @throws \BadMethodCallException The function target is not callable.
   */
  function throw(string $className = ''): self {
    if (!is_callable($this->target)) throw new \BadMethodCallException('The function target is not callable.');

    $exception = null;
    try { call_user_func($this->target); }
    catch (\Throwable $e) { $exception = $e; }

    $constraint = logicalNot(isNull());
    return $this->expect($exception, mb_strlen($className) ? logicalAnd($constraint, isInstanceOf($className)) : $constraint);
  }

  /**
   * Reports an error if the target is `false`.
   * @return $this This instance.
   */
  function true(): self {
    return $this->expect($this->target, isTrue());
  }

  /**
   * Reports an error if the target is greater than or less than the specified bounds.
   * @param int|float $start The lowerbound inclusive.
   * @param int|float $finish The upperbound inclusive.
   * @return $this This instance.
   */
  function within($start, $finish): self {
    $target = $this->hasFlag('length') ? $this->getLength($this->target) : $this->target;
    return $this->expect($target, logicalAnd(greaterThanOrEqual($start), lessThanOrEqual($finish)));
  }

  /**
   * Reports an error if the file or directory specified by the target is not writable.
   * @return $this This instance.
   * @throws \BadMethodCallException This assertion is not a file or directory one.
   */
  function writable(): self {
    if (!$this->hasFlag('directory') && !$this->hasFlag('file'))
      throw new \BadMethodCallException('This assertion is not a file or directory one.');

    return $this->expect($this->target, isWritable());
  }

  /**
   * Indicates that the assertion following in the chain targets XML data.
   * @return $this This instance.
   */
  function xml(): self {
    return $this->setFlag('xml');
  }

  /**
   * Asserts that the specified target matches the specified constraint.
   * @param mixed $target The target to check.
   * @param Constraint $constraint The constraint to match.
   * @return $this This instance.
   */
  private function expect($target, Constraint $constraint): self {
    assertThat($target, $this->hasFlag('negate') ? logicalNot($constraint) : $constraint, $this->message);
    return $this;
  }

  /**
   * Returns the length of the specified value.
   * @param mixed $value An iterable value, like an array or a string.
   * @return int The length of the specified value.
   * @throws \InvalidArgumentException The specified value is not iterable.
   */
  private function getLength($value): int {
    if (is_array($value) || $value instanceof \Countable) return count($value);
    if ($value instanceof \Traversable) return iterator_count($value);
    if (is_string($value)) return mb_strlen($value);
    throw new \InvalidArgumentException("The specified value is not iterable: $value");
  }

  /**
   * Gets a value indicating whether this assertion has the specified flag.
   * @param string $name The flag name.
   * @return bool `true` if this assertion has the specified flag, otherwise `false`.
   */
  private function hasFlag(string $name): bool {
    return $this->flags[$name] ?? false;
  }

  /**
   * Sets a value indicating whether this assertion has the specified flag.
   * @param string $name The flag name.
   * @param bool $value `true` if this assertion has the specified flag, otherwise `false`.
   * @return $this This instance.
   */
  private function setFlag(string $name, bool $value = true): self {
    $this->flags[$name] = $value;
    return $this;
  }
}
